---
name: verifying-plans
description: "Use when a plan has been written and is about to be executed, or the user says 'verify plan'. Applies Verification-First method with falsifiable error candidates, failure reverse reasoning, and optional Design Token consistency checks for UI plans."
---

## 触发时机

- Plan mode 下计划写完后，执行前
- 用户说"验证一下计划"、"check the plan"、"verify plan"

## 原理

验证（反向推理）比生成（正向推理）认知负担低，且产出的信息与正向推理互补。批评外部输入比自我审查更能激活批判性思维。因此：**不做抽象检查，做具体断言验证。**

## 流程

### 1. 计划分类

读取当前计划，判断类型（可重叠）：

| 类型 | 识别信号 | 适用策略 |
|------|---------|---------|
| 架构变更 | 新增 Service/Agent/Tool、改数据流、新增事件入口、替代组件 | S1 + S2 |
| 功能开发 | 新增/修改功能、改已有代码行为 | S1 |
| UI 开发 | 新建/修改 View、组件样式、布局 | S1 + U1 |
| 多步骤执行 | 步骤 ≥ 5 且有编译/运行时依赖 | S2 |

### 2. 执行适用策略

---

#### S1. 具体候选错误验证

**目的**：通过验证具体的错误断言，触发反向推理路径。

步骤：
1. 基于计划内容和代码库现状，**生成 3-5 条具体的、可证伪的错误断言**
2. 每条断言必须包含：具体步骤编号 + 具体文件/函数 + 具体的错误后果
3. 逐条验证，引用代码库中的文件:行号

**断言生成规则**：
- 必须足够具体以至于可以通过读代码证实或证伪（"可能有边界值问题" = 太抽象，禁止）
- 覆盖以下维度（不必全覆盖，选计划最薄弱的 3-5 条）：
  - 集成断裂：步骤 X 创建的东西在步骤 Y 的消费者中是否被正确引用？
  - 隐式依赖：步骤 X 是否假设了某个前置条件但计划未显式建立？
  - 旧代码影响：计划修改的文件中，未被计划提及的其他函数是否会受影响？
  - 状态可达性：计划引入的新状态值，现有的 switch/if 是否全部覆盖？
  - 删除遗漏：计划说"替代 X"但未列出 X 的所有引用位置？

**输出格式**：

```
[断言 1] 步骤 {N}：{具体错误描述，如 "FeynmanStudentAgent 在 LearningOrchestrator.registerAgents() 中未注册，导致 Feynman 模式下该 Agent 不会被调用"}
验证：读取 {file:line}
结果：✅ 断言不成立（{证据}） / ❌ 断言成立 → 计划需补充：{具体修订}

[断言 2] ...
```

**关键**：即使所有断言都不成立，验证过程本身已经产出了正向规划未覆盖的推理路径。如果验证过程中发现断言不成立但暴露了**另一个问题**，必须记录。

---

#### S2. 失败反向推理

**目的**：从执行结果反推计划缺陷，捕获步骤间依赖和顺序问题。

步骤：
1. 假设计划已执行完毕但 build 失败，推理最可能的编译错误是什么（引用具体步骤和文件）
2. 假设 build 通过但运行时出现 regression，推理最可能的 regression 是什么（引用具体用户操作路径）
3. 对每个推理出的失败，检查计划是否已覆盖

**输出格式**：

```
[编译失败推理]
假设失败：{具体错误，如 "步骤 3 新增的 Protocol 要求步骤 5 的类 conform，但步骤 5 在步骤 3 之后才修改该类"}
计划覆盖：✅ 步骤 {N} 已处理 / ❌ 未覆盖 → 计划需补充：{具体修订}

[运行时 Regression 推理]
假设 regression：{具体场景，如 "用户在 Feynman 模式下点击提问，但新增的 guard 检查在 session.state == .paused 时提前 return，导致提问按钮无响应"}
操作路径：{用户动作} → {代码入口 file:line} → {失败点 file:line}
计划覆盖：✅ / ❌ → 计划需补充：{具体修订}
```

---

#### U1. Design Token 一致性验证（UI 计划专用）

**目的**：验证 UI 计划中的所有视觉值有 token 支撑。

步骤：
1. 读取 `DesignTokens.swift`（或项目中的设计系统文件）
2. 从计划中提取所有涉及 UI 的步骤，列出每个步骤会用到的尺寸/间距/颜色/字号
3. 对每个值在 DesignTokens 中查找对应 token

**输出格式**：

```
[Token 检查]
| 步骤 | UI 值 | Token | 状态 |
|------|-------|-------|------|
| 步骤 3 | 卡片圆角 | CardStyle.cornerRadius | ✅ |
| 步骤 3 | 卡片内边距 | — | ⚠️ 缺失 |
| 步骤 5 | 标题字号 | .headline | ✅ |

缺失项处理：
- 卡片内边距：计划需明确是新增 token 还是复用 Spacing.md？
```

补充检查（当计划涉及的目录下已有同类 View 时）：
- 读取已有同类组件，提取其间距/颜色/圆角模式
- 验证计划中新组件是否遵循相同模式
- 不一致处标注：有意偏离 / 遗漏

---

### 3. 汇总与计划修订建议

```
## Plan Verification Summary

### 策略执行
- S1 具体候选错误：生成 {N} 条，成立 {M} 条
- S2 失败反向推理：编译失败 {N} 条，运行时 regression {N} 条
- U1 Token 一致性：检查 {N} 项，缺失 {M} 项

### 计划修订建议

#### 必须修订（验证发现的确实问题）
1. [步骤 X] {具体修订内容}
   依据：{S1/S2/U1 的哪条验证}

#### 建议补充（验证过程中暴露的风险）
1. [步骤 X] {补充内容}
   依据：{验证过程中发现的额外信息}

#### 无需修订（验证通过的部分）
- {列出验证通过的关键断言，证明计划在这些方面是充分的}
```

---

## 原则

1. **具体 > 抽象**：每条断言必须具体到可以通过读代码证实/证伪。"可能有问题"= 无效断言
2. **代码锚定**：所有验证结果必须引用 file:line，不凭推测
3. **错了也有用**：断言被证伪不是失败；验证过程本身产出的推理路径是价值所在
4. **不替代其他 review**：本命令只验证计划完整性和正确性，不做代码质量、UI 合规、架构审查（那些是 `/code-review`、`/ui-review`、`/architecture-review` 的职责）
5. **修订不执行**：本命令只输出修订建议，不直接修改计划。用户确认后再更新
